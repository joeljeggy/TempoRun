import threading
import requests
from spotipy.oauth2 import SpotifyOAuth
import spotipy
from pydantic import BaseModel
from google import genai
import json
import time
import os
from dotenv import load_dotenv
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS 

load_dotenv()

spotify_client_id = os.getenv("SPOTIFY_CLIENT_ID")
spotify_client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
gemini_api_key = os.getenv("GEMINI_API_KEY")

lock = threading.Lock()
stop_thread = False
esp32_ip = "192.168.20.106" # IP address of the esp32 
playlist = None
speed_kmh = 0.0 # current speed in km/h
target_kmh = 0.0 # target speed in km/h
calories = 0 # current calories burned    
threadmill_status = "unknown" # current treadmill status
duration_s = 0 # current duration in seconds
distance_km = 0 # current distance in kilometers
cmd = "none" # command to send to esp32
sl = .75 # stride length
run_sl = 1.2 # running stride length
song = "None" # current song name
nsong = "None" # next song name
bpm = 0 # current song bpm
nbpm = 0 # next song bpm
speed = 0 # current song speed in km/h
nspeed = 0 # next song speed in km/h
trackid = "None" # next song ID
ntrackid = "None" # next song name ID
track_ids = [] # list of track ids generated by Gemini
return_value=0 # return value
# Cover art state (updated only when song changes)
cover_art_url = ""
last_song_for_art = None
workout_time_limit_sec = 1200  # default playlist time limit

# Spotipi setup
sp = spotipy.Spotify(auth_manager=SpotifyOAuth(
        client_id= os.getenv("SPOTIFY_CLIENT_ID"),
        client_secret= os.getenv("SPOTIFY_CLIENT_SECRET"),
        redirect_uri="http://127.0.0.1:8888/callback",
        scope="user-modify-playback-state,user-read-playback-state",
        open_browser=False
))

# Gemini api key
Gemini_api_key= os.getenv("GEMINI_API_KEY")

app = Flask(__name__)
CORS(app)

# ----------- Spotify + Gemini Setup -----------

# Gemini output structure
class Output(BaseModel):
    Warm_up: list[str]
    Running: list[str]
    Sprinting: list[str]
    Cooldown: list[str]

def generate_and_queue_workout_playlist():
    global data,playlist,track_ids,workout_time_limit_sec

    # Gemini API Setup
    client = genai.Client(api_key=Gemini_api_key)

    # Load song data
    with open("songs.json") as f:
        data = json.load(f)

    formatted = ""
    for track in data["tracks"]:
        formatted += f"id {track['id']}, name {track['name']}, artists {track['artists']}, duration {track['duration_sec']}, bpm {track['bpm']}, energy {track['energy']}, danceability {track['danceability']}\n"

    # Get response from Gemini
    response = client.models.generate_content(
        model="gemini-2.5-pro",
        # Prompt for gemini
        contents=["You are my workout assistant.\n\n"+
                  f"{formatted}\n"+
                  " above is my liked songs along with metadata such as spotify id, name, artists, duration in seconds, bpm, energy, and danceability."
                  " Your task is to analyze the tracks and return a subset of songs that are ideal for a treadmill workout."
                  " Use the following criteria:"
                    "Warm-up songs (BPM 90â€“110, moderate energy, high danceability),"
                    "Running songs (BPM 120â€“150, high energy and danceability),"
                    "Sprinting songs (BPM 150â€“180+, very high energy preferred),"
                    "Cooldown songs (BPM < 90, low energy and smooth transitions)."
                  f" Total time should be less than {workout_time_limit_sec} seconds."
                  " Return id of each selected songs in each catagory following the response schema."
                  " Don't include songs that are too low in danceability unless they are clearly for cooldown."
                  " Prioritize diversity in BPM and avoid repeating the same artist too many times in each category."],
        config={
            "response_mime_type": "application/json",
            "response_schema": Output,
        }
    )

    # Decode the response
    try:
        playlist = json.loads(response.text)
    except json.JSONDecodeError as e:
        print("Failed to decode Gemini JSON:", e)
        return
    
    # Print no. of songs and its ids
    print("ðŸŽµ Gemini-generated playlist (by section):")
    for section, tracks in playlist.items():
        print(f"{section}: {len(tracks)} tracks")


    # Queue all tracks
    all_track_ids = []
    for section in playlist:
        all_track_ids.extend(playlist[section])

    for track_id in all_track_ids:
        try:
            sp.add_to_queue(f"spotify:track:{track_id}")
            print(f"Queued: {track_id}")
            time.sleep(0.3)
        except spotipy.exceptions.SpotifyException as e:
            print(f"Failed to queue {track_id}: {e}")

# ----------- flask routes -----------

@app.route("/generate_playlist", methods=["POST"])
def generate_playlist():
    global pending_command,workout_time_limit_sec
    try:
        pending_command = "clear_queue"
        data = request.get_json(silent=True) or {}
        # Accept time_seconds and clamp to reasonable bounds (5 min to 2 hours)
        if isinstance(data.get("time_seconds"), (int, float)):
            ts = int(data["time_seconds"]) if data["time_seconds"] >= 0 else 0
            ts = max(300, min(ts, 7200))  # 5 minutes to 120 minutes
            workout_time_limit_sec = ts
        generate_and_queue_workout_playlist()
        return jsonify({"status": "ok"})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route("/")
def index():
    return render_template("index.html")

@app.route("/status")
def status():
    global last_song_for_art, cover_art_url
    hours = duration_s// 3600
    minutes = (duration_s % 3600) // 60
    secs = duration_s % 60
    treadmill = {
        "status": threadmill_status,
        "speed": speed_kmh,
        "distance": distance_km,
        "time": f"{hours:02}:{minutes:02}:{secs:02}",
        "target": target_kmh,
        "calories": calories
    }

    # If the current song changed, fetch current playback once to get cover art
    if song and song != last_song_for_art:
        try:
            playback = sp.current_playback()
            if playback and playback.get("item"):
                images = playback["item"].get("album", {}).get("images", [])
                cover_art_url = images[0].get("url")
        except Exception as e:
            # Keep previous cover art if Spotify call fails
            pass
        finally:
            last_song_for_art = song

    music = {
        "current": song,
        "next": nsong,
        "current_speed": speed,
        "next_speed": nspeed,
        "cover_url": cover_art_url,
    }
    return jsonify({"treadmill": treadmill, "music": music})

pending_command = None

@app.route("/playlist", methods=["GET"])
def api_playlist():
    """Return the generated playlist."""
    return jsonify(playlist or {})

@app.route("/player/next", methods=["POST"])
def player_next():
    try:
        sp.next_track()
        return jsonify({"status": "ok"})
    except spotipy.exceptions.SpotifyException as e:
        return jsonify({"status": "error", "message": str(e)}), 400

@app.route("/player/previous", methods=["POST"])
def player_previous():
    try:
        sp.previous_track()
        return jsonify({"status": "ok"})
    except spotipy.exceptions.SpotifyException as e:
        return jsonify({"status": "error", "message": str(e)}), 400
    
@app.route("/player/playpause", methods=["POST"])
def player_pp():
    try:
        playback = sp.current_playback()
        if playback and playback.get("is_playing"):
            sp.pause_playback()
        else:
            sp.start_playback()
        return jsonify({"status": "ok"})
    except spotipy.exceptions.SpotifyException as e:
        return jsonify({"status": "error", "message": str(e)}), 400

@app.route("/set_command/<command>", methods=["GET"])
def set_command(command):
    global cmd
    cmd = command
    if cmd == "clear_queue":
        global pending_command
        pending_command = cmd
        print(f"ðŸ“ Command set to: {cmd}")
        return jsonify({"status": "command scheduled", "command": cmd})
    else:
        return jsonify({"status": "success", "command": cmd})

@app.route("/commands", methods=["POST"])
def commands():
    global pending_command ,bpm ,nbpm ,song ,nsong,trackid,ntrackid, speed, nspeed

    data = request.get_json()
    song = data.get("current")
    nsong = data.get("next")
    bpm = data.get("bpm")
    nbpm = data.get("nbpm")
    trackid = data.get("trackId")
    ntrackid = data.get("ntrackId")
    speed = round(bpm * sl * 0.06,1)    #Calculate speed in km/h
    if (speed > 6) :
        speed = round(bpm * run_sl * 0.06,1)    #If running speed use running stride length
    nspeed = round(nbpm * sl * 0.06,1)    #Calculate speed in km/h
    if (nspeed > 6) :
        nspeed = round(nbpm * run_sl * 0.06,1)    #If running speed use running stride length    

    print(f"ðŸŽµ Received -> Current: {song}, Next: {nsong}, BPM: {bpm}, NBPM: {nbpm}")

    # Example: send a command back
    command = pending_command or "none"

    # Once delivered, clear it (optional)
    pending_command = None

    return jsonify({"command": command})

# ----------- ESP32 Command Section -----------

# Thread that fetch the values from esp32
def get_status(session):
    global  stop_thread, speed_kmh, threadmill_status, duration_s, distance_km, target_kmh, calories
    while not stop_thread:
        try:
            response = session.get(f"http://{esp32_ip}/status", timeout=5)
            if response.status_code == 200:
                try:
                    status_data = response.json()
                    with lock:
                        speed_kmh = status_data.get("speed_kmh", 0)
                        target_kmh = status_data.get("target_kmh", 0)
                        threadmill_status = status_data.get("status", "unknown")
                        duration_s = status_data.get("duration_s", 0)
                        distance_km = status_data.get("distance_km", 0)
                        calories = status_data.get("calories", 0)
                except json.JSONDecodeError:
                    print("[ESP32 Status] Failed to parse JSON.")
            else:
                print(f"[ESP32 Status] Error {response.status_code}")
        except requests.RequestException as e:
            print(f"[ESP32 Status] Connection error: {e}")
        time.sleep(.5)

def start_esp32_interface():
    global stop_thread,cmd

    session = requests.Session()

    # Start the background thread
    status_thread = threading.Thread(target=get_status, args=(session,))
    status_thread.daemon = True
    status_thread.start()

    print(f"\nðŸ”Œ Connected to ESP32 at http://{esp32_ip}/")

    try:
        while True:
            if cmd == "start" :

                try:
                    sp.start_playback()
                except Exception as e:
                    print(f"Failed to start song: {e}")
                
                params = {'action': cmd}
                print(params)

                # Send start command
                try:
                    resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                    if resp.ok:
                        print(f"ESP32 <<< {resp.text}")
                    else:
                        print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                except requests.RequestException as e:
                    print(f"Failed to send command: {e}")

                cmd = "none"

                while True:
                    '''current=sp.current_user_playing_track()
                    if current and current.get('item'):
                        song_id = current['item']['id']
                    else:
                        print("No track currently playing.")'''

                    if (speed_kmh != speed) & (speed < 14) & (speed >= 1) :
                        command_input = f'speed {speed}'
                        parts = command_input.lower().strip().split()
                        action = parts[0]
                        params = {'action': action}

                        if len(parts) > 1:
                            params['value'] = parts[1]
                            
                        print(params)
                        try:
                            resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                            if resp.ok:
                                print(f"ESP32 <<< {resp.text}")
                            else:
                                print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                        except requests.RequestException as e:
                            print(f"Failed to send command: {e}")
                        
                    time.sleep(.5)
                    if cmd == "stop" :
                        break
                    elif cmd == "pause" or cmd == "start":
                        params = {'action': cmd}
                        print(params)
                        try:
                            resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                            if resp.ok:
                                print(f"ESP32 <<< {resp.text}")
                            else:
                                print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                        except requests.RequestException as e:
                            print(f"Failed to send command: {e}")
                        cmd = "none"

            if cmd == "stop" :

                params = {'action': cmd}
                print(params)
                try:
                    resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                    if resp.ok:
                        print(f"ESP32 <<< {resp.text}")
                    else:
                        print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                except requests.RequestException as e:
                    print(f"Failed to send command: {e}")
                cmd = "none"
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
    finally:
        stop_thread = True
        print("Stopping thread and exiting...")

def run_flask():
    app.run(host="0.0.0.0", port=5000, debug=False, use_reloader=False)

# ----------- Main Function -----------
def main():
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True
    flask_thread.start()

    #print("ðŸŽ§ Generating treadmill workout playlist using Gemini + Spotify...")
    #generate_and_queue_workout_playlist()

    print("\nðŸ”§ Starting ESP32 command interface...")
    start_esp32_interface()

if __name__ == "__main__":
    main()