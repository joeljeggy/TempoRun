import threading
import requests
from spotipy.oauth2 import SpotifyOAuth
import spotipy
from pydantic import BaseModel
from google import genai
import json
import time
import os
from dotenv import load_dotenv
from flask import Flask, request, jsonify, render_template_string
from flask_cors import CORS 

load_dotenv()

spotify_client_id = os.getenv("SPOTIFY_CLIENT_ID")
spotify_client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
gemini_api_key = os.getenv("GEMINI_API_KEY")

lock = threading.Lock()
stop_thread = False
esp32_ip = "192.168.20.106" # IP address of the esp32 
playlist = None
speed_kmh = None # current speed in km/h
threadmill_status = "unknown" # current treadmill status
duration_s = 0 # current duration in seconds
distance_km = 0 # current distance in kilometers
cmd = "none" # command to send to esp32
sl = .75 # stride length
run_sl = 1.2 # running stride length
song = "None" # current song name
nsong = "None" # next song name
bpm = 0 # current song bpm
nbpm = 0 # next song bpm
speed = 0 # current song speed in km/h
nspeed = 0 # next song speed in km/h
trackid = "None" # next song ID
ntrackid = "None" # next song name ID
track_ids = [] # list of track ids generated by Gemini
return_value=0 # return value
# Cover art state (updated only when song changes)
cover_art_url = ""
last_song_for_art = None

# Spotipi setup
sp = spotipy.Spotify(auth_manager=SpotifyOAuth(
        client_id= os.getenv("SPOTIFY_CLIENT_ID"),
        client_secret= os.getenv("SPOTIFY_CLIENT_SECRET"),
        redirect_uri="http://127.0.0.1:8888/callback",
        scope="user-modify-playback-state,user-read-playback-state",
        open_browser=False
))

# Gemini api key
Gemini_api_key= os.getenv("GEMINI_API_KEY")

app = Flask(__name__)
CORS(app)

# ----------- Spotify + Gemini Setup -----------

# Gemini output structure
class Output(BaseModel):
    Warm_up: list[str]
    Running: list[str]
    Sprinting: list[str]
    Cooldown: list[str]

def generate_and_queue_workout_playlist():
    global data,playlist,track_ids

    # Gemini API Setup
    client = genai.Client(api_key=Gemini_api_key)

    # Load song data
    with open("songs.json") as f:
        data = json.load(f)

    formatted = ""
    for track in data["tracks"]:
        formatted += f"id {track['id']}, name {track['name']}, artists {track['artists']}, duration {track['duration_sec']}, bpm {track['bpm']}, energy {track['energy']}, danceability {track['danceability']}\n"

    # Get response from Gemini
    response = client.models.generate_content(
        model="gemini-2.5-pro",
        # Prompt for gemini
        contents=["You are my workout assistant.\n\n"+
                  f"{formatted}\n"+
                  " above is my liked songs along with metadata such as spotify id, name, artists, duration in seconds, bpm, energy, and danceability."
                  " Your task is to analyze the tracks and return a subset of songs that are ideal for a treadmill workout."
                  " Use the following criteria:"
                    "Warm-up songs (BPM 90‚Äì110, moderate energy, high danceability),"
                    "Running songs (BPM 120‚Äì150, high energy and danceability),"
                    "Sprinting songs (BPM 150‚Äì180+, very high energy preferred),"
                    "Cooldown songs (BPM < 90, low energy and smooth transitions)."
                  " Total time should be less than 1200 seconds."
                  " Return id of each selected songs in each catagory following the response schema."
                  " Don't include songs that are too low in danceability unless they are clearly for cooldown."
                  " Prioritize diversity in BPM and avoid repeating the same artist too many times in each category."],
        config={
            "response_mime_type": "application/json",
            "response_schema": Output,
        }
    )

    # Decode the response
    try:
        playlist = json.loads(response.text)
    except json.JSONDecodeError as e:
        print("Failed to decode Gemini JSON:", e)
        return
    
    # Print no. of songs and its ids
    print("üéµ Gemini-generated playlist (by section):")
    for section, tracks in playlist.items():
        print(f"{section}: {len(tracks)} tracks")


    # Queue all tracks
    all_track_ids = []
    for section in playlist:
        all_track_ids.extend(playlist[section])

    for track_id in all_track_ids:
        try:
            sp.add_to_queue(f"spotify:track:{track_id}")
            print(f"Queued: {track_id}")
            time.sleep(0.3)
        except spotipy.exceptions.SpotifyException as e:
            print(f"Failed to queue {track_id}: {e}")

# ----------- flask routes -----------

HTML_PAGE = """
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Treadmill Control</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
.section { margin-bottom: 30px; }
label { display: block; margin-top: 10px; }
input[type=range] { width: 200px; }
</style>
</head>
<body>

<h1>Treadmill Control Panel</h1>

<div class="section">
  <h2>Controls</h2>
  <button onclick="startrun()">Start</button>
  <button onclick="pauserun()">Pause</button>
  <button onclick="stoprun()">Stop</button>
</div>

<div class="section">
  <h2>Stats</h2>
  <p>status: <span id="status">False</span></p>
  <p>Speed: <span id="statSpeed">0</span> km/h</p>
  <p>Distance: <span id="statDistance">0.0</span> km</p>
  <p>Time: <span id="statTime">0</span> s</p>
</div>

<div class="section">
  <h2>Music</h2>
  <p>Current: <span id="currentSong">None</span> | Speed: <span id="current Speed">0</span></p>
  <p>Next: <span id="nextSong">None</span> | Speed: <span id="next Speed">0</span></p>
    <div style="margin-top:10px;">
        <img id="coverArt" alt="Cover Art" src="" style="max-width: 200px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);"/>
    </div>
    <div style="margin-top:10px; display:flex; gap:10px;">
        <button onclick="prevTrack()">‚èÆÔ∏è Prev</button>
        <button onclick="nextTrack()">‚è≠Ô∏è Next</button>
    </div>
</div>

<script>
const speedSlider = document.getElementById("speed");
const speedValue = document.getElementById("speedValue");

async function startrun() {
    try {
        await fetch("/set_command/start", { method: "GET" });
    } catch (e) {}
}

async function pauserun() {
    try {
        await fetch("/set_command/pause", { method: "GET" });
    } catch (e) {}
}

async function stoprun() {
    try {
        await fetch("/set_command/stop", { method: "GET" });
    } catch (e) {}
}

async function nextTrack() {
    try {
        await fetch("/player/next", { method: "POST" });
    } catch (e) {}
}

async function prevTrack() {
    try {
        await fetch("/player/previous", { method: "POST" });
    } catch (e) {}
}

async function refreshStatus() {
    const res = await fetch("/status");
    const data = await res.json();
    const t = data.treadmill;
    document.getElementById("status").textContent = t.status;
    document.getElementById("statSpeed").textContent = t.speed;
    document.getElementById("statDistance").textContent = t.distance.toFixed(2);
    document.getElementById("statTime").textContent = t.time;

    const m = data.music;
    document.getElementById("currentSong").textContent = m.current;
    document.getElementById("current Speed").textContent = m.current_speed;
    document.getElementById("nextSong").textContent = m.next;
    document.getElementById("next Speed").textContent = m.next_speed;

    // Update cover art only when the song changes
    if (!window.__lastSongDisplayed || window.__lastSongDisplayed !== m.current) {
        const img = document.getElementById("coverArt");
        if (m.cover_url) {
            img.src = m.cover_url;
            img.style.display = "block";
        } else {
            img.src = "";
            img.style.display = "none";
        }
        window.__lastSongDisplayed = m.current;
    }
}

setInterval(refreshStatus, 250);
</script>

</body>
</html>
"""

@app.route("/")
def index():
    return render_template_string(HTML_PAGE)

@app.route("/status")
def status():
    global last_song_for_art, cover_art_url
    hours = duration_s// 3600
    minutes = (duration_s % 3600) // 60
    secs = duration_s % 60
    treadmill = {
        "status": threadmill_status,
        "speed": speed_kmh,
        "distance": distance_km,
        "time": f"{hours:02}:{minutes:02}:{secs:02}"
    }

    # If the current song changed, fetch current playback once to get cover art
    if song and song != last_song_for_art:
        try:
            playback = sp.current_playback()
            if playback and playback.get("item"):
                images = playback["item"].get("album", {}).get("images", [])
                cover_art_url = images[0].get("url")
        except Exception as e:
            # Keep previous cover art if Spotify call fails
            pass
        finally:
            last_song_for_art = song

    music = {
        "current": song,
        "next": nsong,
        "current_speed": speed,
        "next_speed": nspeed,
        "cover_url": cover_art_url,
    }
    return jsonify({"treadmill": treadmill, "music": music})

pending_command = None

@app.route("/playlist", methods=["GET"])
def api_playlist():
    """Return the generated playlist."""
    return jsonify(playlist or {})

@app.route("/player/next", methods=["POST"])
def player_next():
    try:
        sp.next_track()
        return jsonify({"status": "ok"})
    except spotipy.exceptions.SpotifyException as e:
        return jsonify({"status": "error", "message": str(e)}), 400

@app.route("/player/previous", methods=["POST"])
def player_previous():
    try:
        sp.previous_track()
        return jsonify({"status": "ok"})
    except spotipy.exceptions.SpotifyException as e:
        return jsonify({"status": "error", "message": str(e)}), 400

@app.route("/set_command/<command>", methods=["GET"])
def set_command(command):
    global cmd
    cmd = command
    if cmd == "clear_queue":
        global pending_command
        pending_command = cmd
        print(f"üìù Command set to: {cmd}")
        return jsonify({"status": "command scheduled", "command": cmd})
    else:
        return jsonify({"status": "success", "command": cmd})

@app.route("/commands", methods=["POST"])
def commands():
    global pending_command ,bpm ,nbpm ,song ,nsong,trackid,ntrackid, speed, nspeed

    data = request.get_json()
    song = data.get("current")
    nsong = data.get("next")
    bpm = data.get("bpm")
    nbpm = data.get("nbpm")
    trackid = data.get("trackId")
    ntrackid = data.get("ntrackId")
    speed = round(bpm * sl * 0.06,1)    #Calculate speed in km/h
    if (speed > 6) :
        speed = round(bpm * run_sl * 0.06,1)    #If running speed use running stride length
    nspeed = round(nbpm * sl * 0.06,1)    #Calculate speed in km/h
    if (nspeed > 6) :
        nspeed = round(nbpm * run_sl * 0.06,1)    #If running speed use running stride length    

    print(f"üéµ Received -> Current: {song}, Next: {nsong}, BPM: {bpm}, NBPM: {nbpm}")

    # Example: send a command back
    command = pending_command or "none"

    # Once delivered, clear it (optional)
    pending_command = None

    return jsonify({"command": command})

    
'''
@app.route("/response", methods=["POST"])
def response():
    data = request.get_json()
    print(f"‚úÖ Client Response: {data.get('message')}")
    return jsonify({"status": "ok"})
'''

# ----------- ESP32 Command Section -----------

# Thread that fetch the values from esp32
def get_status(session):
    global  stop_thread, speed_kmh, threadmill_status, duration_s, distance_km
    while not stop_thread:
        try:
            response = session.get(f"http://{esp32_ip}/status", timeout=5)
            if response.status_code == 200:
                try:
                    status_data = response.json()
                    with lock:
                        speed_kmh = status_data.get("speed_kmh", 0)
                        threadmill_status = status_data.get("status", "unknown")
                        duration_s = status_data.get("duration_s", 0)
                        distance_km = status_data.get("distance_km", 0)
                except json.JSONDecodeError:
                    print("[ESP32 Status] Failed to parse JSON.")
            else:
                print(f"[ESP32 Status] Error {response.status_code}")
        except requests.RequestException as e:
            print(f"[ESP32 Status] Connection error: {e}")
        time.sleep(.5)

def start_esp32_interface():
    global stop_thread,cmd

    session = requests.Session()

    # Start the background thread
    status_thread = threading.Thread(target=get_status, args=(session,))
    status_thread.daemon = True
    status_thread.start()

    print(f"\nüîå Connected to ESP32 at http://{esp32_ip}/")

    try:
        while True:
            if cmd == "start" :

                try:
                    sp.start_playback()
                except Exception as e:
                    print(f"Failed to start song: {e}")
                
                params = {'action': cmd}
                print(params)

                # Send start command
                try:
                    resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                    if resp.ok:
                        print(f"ESP32 <<< {resp.text}")
                    else:
                        print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                except requests.RequestException as e:
                    print(f"Failed to send command: {e}")

                cmd = "none"

                while True:
                    '''current=sp.current_user_playing_track()
                    if current and current.get('item'):
                        song_id = current['item']['id']
                    else:
                        print("No track currently playing.")'''

                    if (speed_kmh != speed) & (speed < 14) & (speed >= 1) :
                        command_input = f'speed {speed}'
                        parts = command_input.lower().strip().split()
                        action = parts[0]
                        params = {'action': action}

                        if len(parts) > 1:
                            params['value'] = parts[1]
                            
                        print(params)
                        try:
                            resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                            if resp.ok:
                                print(f"ESP32 <<< {resp.text}")
                            else:
                                print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                        except requests.RequestException as e:
                            print(f"Failed to send command: {e}")
                        
                    time.sleep(.5)
                    if cmd == "stop" :
                        break
                    elif cmd == "pause" or cmd == "start":
                        params = {'action': cmd}
                        print(params)
                        try:
                            resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                            if resp.ok:
                                print(f"ESP32 <<< {resp.text}")
                            else:
                                print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                        except requests.RequestException as e:
                            print(f"Failed to send command: {e}")
                        cmd = "none"

            if cmd == "stop" :

                params = {'action': cmd}
                print(params)
                try:
                    resp = session.get(f"http://{esp32_ip}/command", params=params, timeout=5)
                    if resp.ok:
                        print(f"ESP32 <<< {resp.text}")
                    else:
                        print(f"ESP32 <<< Error: {resp.status_code} - {resp.text}")
                except requests.RequestException as e:
                    print(f"Failed to send command: {e}")
                cmd = "none"
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
    finally:
        stop_thread = True
        print("Stopping thread and exiting...")

def run_flask():
    app.run(host="0.0.0.0", port=5000, debug=False, use_reloader=False)

# ----------- Main Function -----------
def main():
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True
    flask_thread.start()

    print("üéß Generating treadmill workout playlist using Gemini + Spotify...")
    generate_and_queue_workout_playlist()

    print("\nüîß Starting ESP32 command interface...")
    start_esp32_interface()

if __name__ == "__main__":
    main()